<?php

namespace Infocyph\TakingBytes\Email;

class EmailerX
{
    private $smtpConfigured = false;
    private $smtpConfig = [];
    private $to = [];
    private $cc = [];
    private $bcc = [];
    private $from = []; // Changed to array to store from info
    private $replyTo;
    private $subject;
    private $plainText;
    private $htmlContent;
    private $attachments = [];
    private $boundaryAlternative;
    private $boundaryMixed = null;
    private $status = [
        'sent' => false,
        'error' => '',
        'details' => []
    ];

    public function __construct($fromEmail, $fromName)
    {
        $this->from = [
            'email' => $this->encodeNonAscii($fromEmail),
            'name' => $this->encodeNonAscii($fromName)
        ];
        $this->boundaryAlternative = sha1(uniqid(time(), true));
        $this->replyTo = $this->from['email']; // Default Reply-To if not provided
    }

    public function setSMTP(array $smtpConfig)
    {
        $this->smtpConfig = array_merge([
            'host' => '',
            'auth' => false,
            'username' => '',
            'password' => '',
            'port' => 25,
            'secure' => null // TLS or SSL
        ], $smtpConfig);

        $this->smtpConfigured = true;
        return $this;
    }

    public function to($email)
    {
        $this->to[] = $this->encodeNonAscii($email);
        return $this;
    }

    public function cc($email)
    {
        $this->cc[] = $this->encodeNonAscii($email);
        return $this;
    }

    public function bcc($email)
    {
        $this->bcc[] = $this->encodeNonAscii($email);
        return $this;
    }

    public function subject($subject)
    {
        $this->subject = $this->encodeMimeHeader($subject);
        return $this;
    }

    public function plainText($text)
    {
        $this->plainText = $text;
        return $this;
    }

    public function htmlContent($html)
    {
        $this->htmlContent = $html;
        return $this;
    }

    public function replyTo($email)
    {
        $this->replyTo = $this->encodeNonAscii($email);
        return $this;
    }

    public function attachment($filePath, $filename = null)
    {
        if (file_exists($filePath)) {
            $this->attachments[] = ['path' => $filePath, 'name' => $filename ?: basename($filePath)];
            $this->boundaryMixed = sha1(uniqid(time(), true));
        } else {
            $this->status['error'] = "File not found: $filePath";
        }
        return $this;
    }

    public function send()
    {
        if (!$this->validateRequiredFields()) {
            return false;
        }

        $this->generatePlainTextFromHtml();

        $headers = $this->buildHeaders();
        $message = $this->buildBody();

        if ($this->smtpConfigured) {
            return $this->sendViaSMTP($message, $headers);
        } else {
            return $this->sendViaMailFunction($message, $headers);
        }
    }

    private function validateRequiredFields()
    {
        if (empty($this->to) || empty($this->from['email']) || empty($this->subject)) {
            $this->status['error'] = 'Missing essential email data (to, from, subject)';
            return false;
        }

        return true;
    }

    private function generatePlainTextFromHtml()
    {
        if (empty($this->plainText) && !empty($this->htmlContent)) {
            $this->plainText = strip_tags($this->htmlContent); // Automatically set plain text if not provided
        }
    }

    private function buildHeaders()
    {
        $headers = "From: =?UTF-8?B?" . base64_encode($this->from['name']) . "?= <{$this->from['email']}>\r\n"
            . "Reply-To: {$this->replyTo}\r\n";

        if (!empty($this->cc)) {
            $headers .= "Cc: " . implode(',', $this->cc) . "\r\n";
        }

        if (!empty($this->bcc)) {
            $headers .= "Bcc: " . implode(',', $this->bcc) . "\r\n";
        }

        $headers .= "MIME-Version: 1.0\r\n";

        if (!empty($this->attachments)) {
            $headers .= "Content-Type: multipart/mixed; boundary=\"{$this->boundaryMixed}\"\r\n";
        } else {
            $headers .= "Content-Type: multipart/alternative; boundary=\"{$this->boundaryAlternative}\"\r\n";
        }

        return $headers;
    }

    private function buildBody()
    {
        $message = "";

        if (!empty($this->attachments)) {
            $message .= "--{$this->boundaryMixed}\r\n";
            $message .= "Content-Type: multipart/alternative; boundary=\"{$this->boundaryAlternative}\"\r\n\r\n";
        }

        $message .= $this->buildPlainTextPart();
        $message .= $this->buildHtmlPart();

        $message .= "--{$this->boundaryAlternative}--\r\n";

        if (!empty($this->attachments)) {
            $message .= $this->buildAttachmentsPart();
            $message .= "--{$this->boundaryMixed}--\r\n";
        }

        return $message;
    }

    private function buildPlainTextPart()
    {
        if (empty($this->plainText)) {
            return '';
        }

        return "--{$this->boundaryAlternative}\r\n"
            . "Content-Type: text/plain; charset=UTF-8\r\n"
            . "Content-Transfer-Encoding: 7bit\r\n\r\n"
            . "{$this->plainText}\r\n\r\n";
    }

    private function buildHtmlPart()
    {
        if (empty($this->htmlContent)) {
            return '';
        }

        return "--{$this->boundaryAlternative}\r\n"
            . "Content-Type: text/html; charset=UTF-8\r\n"
            . "Content-Transfer-Encoding: quoted-printable\r\n\r\n"
            . "{$this->encodeQuotedPrintable($this->htmlContent)}\r\n\r\n";
    }

    private function buildAttachmentsPart()
    {
        $attachmentsPart = "";
        foreach ($this->attachments as $attachment) {
            $filePath = $attachment['path'];
            $fileName = $attachment['name'];
            $fileType = mime_content_type($filePath);
            $fileContent = chunk_split(base64_encode(file_get_contents($filePath)));

            $attachmentsPart .= "--{$this->boundaryMixed}\r\n"
                . "Content-Type: $fileType; name*=\"UTF-8''" . rawurlencode($fileName) . "\"\r\n"
                . "Content-Disposition: attachment; filename*=\"UTF-8''" . rawurlencode($fileName) . "\"\r\n"
                . "Content-Transfer-Encoding: base64\r\n\r\n"
                . "$fileContent\r\n\r\n";
        }
        return $attachmentsPart;
    }

    private function sendViaMailFunction($message, $headers)
    {
        $toRecipients = implode(',', $this->to);

        if (mail($toRecipients, $this->subject, $message, $headers)) {
            $this->status['sent'] = true;
            $this->status['details'] = [
                'to' => $this->to,
                'cc' => $this->cc,
                'bcc' => $this->bcc,
                'subject' => $this->subject,
                'attachments' => $this->attachments,
                'reply_to' => $this->replyTo
            ];
            return true;
        } else {
            $this->status['error'] = 'Failed to send email';
            return false;
        }
    }

    private function sendViaSMTP($message, $headers)
    {
        $smtpHost = $this->smtpConfig['host'];
        $smtpPort = $this->smtpConfig['port'];
        $smtpUser = $this->smtpConfig['username'];
        $smtpPass = $this->smtpConfig['password'];
        $smtpSecure = $this->smtpConfig['secure'];

        $connection = fsockopen($smtpHost, $smtpPort, $errno, $errstr, 30);

        if (!$connection) {
            $this->status['error'] = "Failed to connect to SMTP server: $errstr ($errno)";
            return false;
        }

        $this->getServerResponse($connection);

        if ($smtpSecure === 'tls') {
            fwrite($connection, "EHLO $smtpHost\r\n");
            $this->getServerResponse($connection);

            fwrite($connection, "STARTTLS\r\n");
            $this->getServerResponse($connection);

            stream_socket_enable_crypto($connection, true, STREAM_CRYPTO_METHOD_TLS_CLIENT);
        } elseif ($smtpSecure === 'ssl') {
            stream_socket_enable_crypto($connection, true, STREAM_CRYPTO_METHOD_SSLv23_CLIENT);
            fwrite($connection, "EHLO $smtpHost\r\n");
            $this->getServerResponse($connection);
        } else {
            fwrite($connection, "EHLO $smtpHost\r\n");
            $this->getServerResponse($connection);
        }

        fwrite($connection, "AUTH LOGIN\r\n");
        $this->getServerResponse($connection);

        fwrite($connection, base64_encode($smtpUser) . "\r\n");
        $this->getServerResponse($connection);

        fwrite($connection, base64_encode($smtpPass) . "\r\n");
        $this->getServerResponse($connection);

        fwrite($connection, "MAIL FROM: <{$this->from['email']}>\r\n");
        $this->getServerResponse($connection);

        foreach ($this->to as $recipient) {
            fwrite($connection, "RCPT TO: <$recipient>\r\n");
            $this->getServerResponse($connection);
        }

        fwrite($connection, "DATA\r\n");
        $this->getServerResponse($connection);

        fwrite($connection, "$headers\r\n$message\r\n.\r\n");
        $this->getServerResponse($connection);

        fwrite($connection, "QUIT\r\n");
        fclose($connection);

        $this->status['sent'] = true;
        return true;
    }

    private function getServerResponse($connection)
    {
        $response = fgets($connection, 512);
        if (strpos($response, '250') === false && strpos($response, '354') === false) {
            $this->status['error'] = "SMTP Error: $response";
        }
    }

    private function encodeNonAscii($string)
    {
        return preg_replace_callback('/[^\x20-\x7E]/', function ($matches) {
            return '=?UTF-8?B?' . base64_encode($matches[0]) . '?=';
        }, $string);
    }

    private function encodeMimeHeader($text)
    {
        return '=?UTF-8?B?' . base64_encode($text) . '?=';
    }

    private function encodeQuotedPrintable($string)
    {
        return quoted_printable_encode($string);
    }
}
